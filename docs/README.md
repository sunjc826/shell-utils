---
layout: page
title: About
permalink: /
nav-order: 1
---

# bash-utils

## About

**bash-utils** is a comprehensive scripting framework designed to make Bash development more productive and maintainable. It provides a complete toolkit for building command-line applications with modern features like intelligent autocompletion, argument parsing, and seamless IDE integration.

### Core Strengths

**üîß Language Server Integration**  
Works seamlessly with Bash language server for Go-To definition, code completion, and intelligent suggestions.
When sourcing a library script from your code, the language server will see all the defined function and variable symbols.

**‚öôÔ∏è Unified Argument Handling**  
Argument parsing, autocompletion generation, and variable binding are tightly coupled in a single place, keeping your code DRY and maintainable.

**üìù Flexible Argument Parsing**  
Supports multiple argument styles:
- Positional arguments (`bu_parse_positional`)
- Keyword arguments (`bu_parse_multiselect`)
- Subparsers (`bu_parse_nested`)
- Recursive calls into other commands (`bu_parse_command_context`)

**‚ö° Intelligent Autocompletion**
- **Lazy**: High-performance completion generation
- **Instant**: No compilation phase‚Äîmodify your script and see completion suggestions update immediately
- **Accurate**: Script parsing and autocompletion work together for precise suggestions
- **Flexible**: Run any Bash command to generate completions, supporting even complex custom rules

**üîí Safety**  
C++ RAII-like state management using a scope stack ensures correct resource handling and prevents common scripting errors like forgetting cleanups.

**üöÄ Performance-Optimized**  
- Minimizes process forking in hot paths
- Custom `source` implementation prevents unnecessary script re-sourcing

**üéØ Everything is a Script**  
Even built-in commands are just scripts. The framework is fully extensible‚Äîcommands like [bu-import-environment.sh][bu-import-environment] and [bu-get-command.sh][bu-get-command] are generated by [bu-new-command.sh][bu-new-command] itself, demonstrating the power of staying within pure Bash.
In fact, the "progenitor" [bu-new-command.sh][bu-new-command] is itself a script of a similar structure.

### Additional Features

- **Rich library functions** with `bu_` prefix for common scripting tasks
- **Server environment support** with automatic VSCode CLI linking
- **Powerful key bindings** including fzf-based autocompletion (Ctrl-X, Ctrl-Space)


When comparing against other Bash frameworks, it does *not*
- Convert a non-Bash DSL script specification like YAML into a Bash script parser. We stay ~100% in Bash-land.
- Provide a package manager: I.e. no special `import`/`load` function or command. There is however, a single `BU_MODULE_PATH` variable.

## Usage
Run this:
```sh
source ./bu_entrypoint.sh
```
Consider adding this to the .bashrc to always activate on load.

The core CLI is `bu`. Run `bu` directly to see the help.
The name of the core CLI is modifiable. For example,
```sh
BU_USER_DEFINED_CLI_COMMAND_NAME=mycli
source ./bu_entrypoint.sh
```
will result in the `mycli` as the core CLI rather than `bu`. Though `bu` is still defined for ease of scripting (i.e. both `mycli` and `bu` will be defined).
There are other tweakable aspects of bash-utils, as we will list out below.

### Tweaking
#### Using variables
Bash variables are all strings/arrays of strings/maps of strings, alongside some variable attributes (e.g. number `-i`, readonly `-r` etc.) but we can interpret them differently.
These variables are "declared" (really, it's for shellcheck hovering over hints) in [bu_user_defined_decl.sh][bu_user_defined_decl].

The customizable variables all have the `BU_USER_DEFINED_` prefix.

Let us define the following conventional variable "types":
- `Function`: The variable name is a function
- `AbsPath[A]`: The variable name is an absolute path, where A is an optional annotation for the type of file we would expect at the end of the path. Some common annotations include:
  - ExecutableScript: A script that is executable
  - SourceableScript: A script that is meant to be sourced 
- `RelPath[A]`: The variable name is a relative path
- `Path[A]`: `AbsPath[A]|RelPath[A]`
- `Int`: The variable is an integer
- `T *`, or `Ref[T]`: The variable is a nameref to T, where T is some parameterized type.
- `Array[T]`: The variable is a Bash array of type T, where T is some parameterized type.
- `Map[K, V]`: The variable is a Bash associative array, where K, V are some parameterized types

Variable list:
- `BU_USER_DEFINED_STATIC_CONFIGS`: `Array[ Function | Path[SourceableScript] ]`
- `BU_USER_DEFINED_DYNAMIC_CONFIGS`: `Array[ Function | Path[SourceableScript] ]`
- `BU_USER_DEFINED_STATIC_PRE_INIT_ENTRYPOINT_CALLBACKS`: `Array[ Function | Path[SourceableScript] ]`
- `BU_USER_DEFINED_DYNAMIC_POST_ENTRYPOINT_CALLBACKS`: `Array[ Function | Path[SourceableScript] ]`
- `BU_USER_DEFINED_STATIC_POST_ENTRYPOINT_CALLBACKS`: `Array[ Function | Path[SourceableScript] ]`
- `BU_USER_DEFINED_DYNAMIC_POST_ENTRYPOINT_CALLBACKS`: `Array[ Function | Path[SourceableScript] ]`
- `BU_USER_DEFINED_COMPLETION_COMMAND_TO_KEY_CONVERSIONS`: `Array[Function]`
- `BU_USER_DEFINED_AUTOCOMPLETE_HELPERS`: `Array[Function]`
- `BU_USER_DEFINED_CLI_COMMAND_NAME`: `Function`

#### Using pre-init functions
Another point of customization are the pre-init functions. They are found in [bu_core_preinit.sh][bu_core_preinit]. They all have the `bu_preinit_` prefix.

- `bu_preinit_register_user_defined_key_binding`:
  - Description: Register a key binding for interactive shells. Values are stored in `BU_KEY_BINDINGS` and later applied via `bind -x`.
  - Params: `$1` = key sequence (e.g. `\ee`), `$2` = command/function to invoke.
  - Example: `bu_preinit_register_user_defined_key_binding '\em' my_custom_edit`

- `bu_preinit_register_user_defined_completion_func`:
  - Description: Register a completion function for a specific command. Mappings are stored in `BU_AUTOCOMPLETE_COMPLETION_FUNCS` and used to call `complete -F`.
  - Params: `$1` = command name, `$2` = completion function name.
  - Example: `bu_preinit_register_user_defined_completion_func mycmd __mycmd_completion`

- `bu_preinit_register_user_defined_subcommand_dir`:
  - Description: Register a directory containing subcommand scripts. Optionally provide a conversion function to transform file names to `verb-noun` command names.
  - Params: `$1` = directory path, `...` = optional conversion function and args.
  - Example: `bu_preinit_register_user_defined_subcommand_dir ~/my-commands bu_convert_file_to_command_namespace prefix`

- `bu_preinit_register_user_defined_subcommand_file`:
  - Description: Register a single script file as a `bu` subcommand.
  - Params: `$1` = file path, `$2` (optional) = command name (derived from filename if omitted), `$3` (optional) = type (`function`, `execute`, `source`).
  - Example: `bu_preinit_register_user_defined_subcommand_file ~/scripts/get-status.sh get-status execute`

- `bu_preinit_register_user_defined_subcommand_function`:
  - Description: Register an in-shell function as a `bu` subcommand.
  - Params: `$1` = function name, `$2` (optional) = command name, `$3` (optional) = type.
  - Example: `bu_preinit_register_user_defined_subcommand_function my_helper_func my-helper function`

- `bu_preinit_register_new_alias`:
  - Description: Create a `bu` alias that expands a positional-style invocation into a named-argument command. Alias specs use `{}` for a single positional, `{...}` for remaining input, and `{?}` for optional remaining input.
  - Params: `$1` = alias name, `$2..` = alias spec (see `bu_preinit_register_new_alias` for syntax rules).
  - Example: `bu_preinit_register_new_alias gc get-command --namespace {} {?} --verb {} {?} --noun {} {...}`

### Library
The core library is in [core][core]
- [bu_core_base.sh][bu_core_base] provides the core library functions for the framework
- [bu_core_autocomplete.sh][bu_core_autocomplete] provides the autocompletion functionality for the `bu` command and the scripts it invokes.

There are library functions that are not used by the core scripting framework, but are nonetheless useful in writing your own scripts.
- [bu_core_tmux.sh][bu_core_tmux] provides imperative utilities (`bu_spawn`) for orchestrating jobs across tmux panes.

{% capture github_base %}{{ site.github.repository_url }}/blob/{{ site.github.build_revision }}/{% endcapture %}
{% capture links %}

[commands]: ../commands/
[bu-import-environment]: ../commands/bu-import-environment.sh
[bu-get-command]: ../commands/bu-get-command.sh
[bu-new-command]: ../commands/bu-new-command.sh
[bu-run-example]: ../examples/commands/bu-run-example.sh
[bu_user_defined_decl]: ../bu_user_defined_decl.sh
[bu_core_preinit]: ../lib/core/bu_core_preinit.sh
[core]: ../lib/core/
[bu_core_base]: ../lib/core/bu_core_base.sh
[bu_core_autocomplete]: ../lib/core/bu_core_autocomplete.sh
[bu_core_tmux]: ../lib/core/bu_core_tmux.sh

{% endcapture %}
<!-- https://shopify.github.io/liquid/filters/replace_first/ -->
<!-- https://stackoverflow.com/questions/27694610/how-can-i-split-a-string-by-newline-in-shopify -->
{% assign links_list = links | newline_to_br | split: '<br />' %}
{% for link in links_list %}
{{ link | replace_first: "../", github_base }}
{% endfor %}
